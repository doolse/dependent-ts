// DepJS Grammar
// Uses GLR features to handle arrow function and other ambiguities

@top Program { statement* }

@external tokens spaceTokens from "./tokens" {
  ltType              // < for type arguments (no preceding space)
  ltCompare[@name="<"] // < for comparison (preceding space)
}

// ============================================
// Statements
// ============================================

statement {
  ConstDecl |
  TypeDecl |
  NewtypeDecl |
  ImportDecl |
  ExportDecl |
  ExpressionStatement
}

ConstDecl {
  kw<"comptime">? kw<"const"> identifierOrTypeName TypeAnnotation? "=" expression ";"
}

TypeDecl {
  Annotation* kw<"type"> TypeName TypeParams? "=" typeExpression ";"
}

NewtypeDecl {
  kw<"newtype"> TypeName "=" typeExpression ";"
}

ImportDecl {
  kw<"import"> ImportClause kw<"from"> String ";"
}

ImportClause {
  DefaultImport { identifier } |
  NamedImports { "{" ListOf<ImportSpecifier>? "}" } |
  NamespaceImport { "*" kw<"as"> identifier } |
  DefaultAndNamed { identifier "," "{" ListOf<ImportSpecifier>? "}" }
}

ImportSpecifier { identifier (kw<"as"> identifier)? }

ExportDecl {
  kw<"export"> (ConstDecl | TypeDecl | NewtypeDecl)
}

ExpressionStatement {
  expression ";"
}

// ============================================
// Expressions
// ============================================

// Arrow functions are at expression level with dynamic precedence
// This allows the GLR parser to try both interpretations and prefer arrow when => follows
expression {
  ArrowFn |
  TernaryExpr |
  binaryExpr
}

// Arrow function with high dynamic precedence to prefer over parenthesized expressions
ArrowFn[@dynamicPrecedence=2] {
  kw<"async">? ArrowParams "=>" ArrowBody
}

// Arrow params: either single identifier or parenthesized list
// ~arrow marks GLR split point - allows (x) to be parsed as both
// arrow params and paren expr until we see => or not
ArrowParams {
  identifier ~arrow |
  "(" ListOf<ArrowParam>? ")" TypeAnnotation?
}

// Arrow params can be lowercase or uppercase (for type params like T)
// Rest parameter uses Spread prefix: ...param
ArrowParam {
  Spread? identifierOrTypeName ~arrow TypeAnnotation? DefaultValue?
}

DefaultValue { "=" expressionNoComma }

ArrowBody {
  expressionNoComma |
  Block
}

// Expression without comma operator (for arrow bodies, ternary branches, etc.)
expressionNoComma {
  ArrowFn |
  TernaryExpr |
  binaryExpr
}

TernaryExpr { binaryExpr !ternary "?" expressionNoComma ":" expressionNoComma }

binaryExpr {
  unaryExpr |
  BinaryExpr { binaryExpr !or "||" binaryExpr } |
  BinaryExpr { binaryExpr !and "&&" binaryExpr } |
  BinaryExpr { binaryExpr !bitor BitOr binaryExpr } |
  BinaryExpr { binaryExpr !bitxor "^" binaryExpr } |
  BinaryExpr { binaryExpr !bitand BitAnd binaryExpr } |
  BinaryExpr { binaryExpr !equality ("==" | "!=") binaryExpr } |
  BinaryExpr { binaryExpr !compare (ltCompare | ">" | "<=" | ">=") binaryExpr } |
  BinaryExpr { binaryExpr !add ("+" | "-") binaryExpr } |
  BinaryExpr { binaryExpr !mult ("*" | "/" | "%") binaryExpr }
}

unaryExpr {
  UnaryExpr { !unary ("!" | "-" | "~") unaryExpr } |
  AwaitExpr { !await kw<"await"> unaryExpr } |
  postfixExpr
}

postfixExpr {
  atomExpr |
  CallExpr { postfixExpr !call "(" ListOf<Argument>? ")" } |
  TypeCallExpr { postfixExpr !typeCall ltType ListOf1<typeExpression> ">" ("(" ListOf<Argument>? ")")? } |
  MemberExpr { postfixExpr !member "." PropertyName } |
  IndexExpr { postfixExpr !member "[" expression "]" }
}

Argument { Spread? expressionNoComma }
Spread { "..." }

// ~arrow: GLR split for (x) => vs (x) parenthesized
// ~record: GLR split for { x } record vs { x } block
atomExpr {
  VariableExpr { identifier ~arrow ~record } |
  TypeExpr { TypeName ~arrow ~record } |
  Literal |
  TemplateExpr |
  ArrayExpr { "[" ListOf<ArrayElement>? "]" } |
  RecordExpr { "{" ListOf<RecordField>? "}" } |
  MatchExpr |
  ThrowExpr { kw<"throw"> unaryExpr } |
  ParenExpr { "(" expression ")" }
}

// Template literals with interpolation
// `hello` or `hello ${name}, you have ${count} messages`
TemplateExpr {
  TemplatePlain |
  TemplateStart expression (TemplateMiddle expression)* TemplateEnd
}

ArrayElement { Spread? expressionNoComma }

RecordField {
  SpreadField { Spread expressionNoComma } |
  FieldDef { PropertyName (":" expressionNoComma)? }
}

// Block always contains statements or ends with expression
// Distinguished from record by requiring at least one stmt or trailing semicolon
Block { "{" BlockContent "}" }

BlockContent {
  statement+ expression? |
  expression
}

MatchExpr {
  kw<"match"> "(" expression ")" "{" MatchCase* "}"
}

MatchCase {
  kw<"case"> Pattern Guard? ":" expression ";"
}

Pattern {
  WildcardPattern { "_" } |
  LiteralPattern { Literal } |
  TypePattern { TypeName } |
  DestructurePattern { "{" ListOf<PatternField>? "}" } |
  BindingPattern { identifier }
}

PatternField { PropertyName (":" Pattern)? }

Guard { kw<"when"> expression }

// ============================================
// Type Expressions
// ============================================

typeExpression {
  unionType
}

unionType {
  intersectionType |
  UnionType { unionType !union BitOr intersectionType }
}

intersectionType {
  primaryType |
  IntersectionType { intersectionType !intersection BitAnd primaryType }
}

primaryType {
  NamedType { TypeName TypeArgs? ArraySuffix* } |
  RecordType { "{" ListOf<TypeField>? "}" } |
  ClosedRecordType { "{|" ListOf<TypeField>? "|}" } |
  IndexedRecordType { "{" IndexSignature "}" } |
  TupleType { "[" ListOf<TupleElement>? "]" } |
  FunctionType { FunctionTypeParams? "(" ListOf<FuncParam>? ")" "=>" typeExpression } |
  ParenType { "(" typeExpression ")" ArraySuffix* } |
  LiteralType { String | Number | kw<"true"> | kw<"false"> }
}

TypeArgs { ltType ListOf1<typeExpression> ">" }
ArraySuffix { "[" "]" }

TypeField {
  Annotation* PropertyName Optional? ":" typeExpression
}

Optional { "?" }

IndexSignature {
  "[" identifier ":" typeExpression "]" ":" typeExpression
}

// TupleElement must have a type - can't be empty
// Supports: Type, label: Type, ...Type
TupleElement {
  Spread typeExpression |
  (identifier ":")? typeExpression
}

// Function type params: name?: type or ...name: type (rest)
FuncParam {
  Annotation* Spread? identifier Optional? ":" typeExpression
}

// ============================================
// Type Parameters and Annotations
// ============================================

TypeParams {
  ltType ListOf1<TypeParam> ">"
}

// FunctionTypeParams allows < with or without preceding space
// This handles cases like `type Identity = <T>(x: T) => T` where space precedes <
FunctionTypeParams[@name="TypeParams"] {
  (ltType | ltCompare) ListOf1<TypeParam> ">"
}

TypeParam {
  Annotation* TypeName (kw<"extends"> typeExpression)? ("=" typeExpression)?
}

TypeAnnotation { ":" typeExpression }

// Annotations can be calls like @JsonName("x") so use postfixExpr
Annotation { "@" postfixExpr }

// ============================================
// Literals
// ============================================

Literal {
  String |
  Number |
  BooleanLiteral { kw<"true"> | kw<"false"> } |
  NullLiteral { kw<"null"> } |
  UndefinedLiteral { kw<"undefined"> }
}

// ============================================
// Helper rules
// ============================================

ListOf<item> { item ("," item)* ","? }
ListOf1<item> { item ("," item)* }

kw<term> { @specialize[@name={term}]<VariableName, term> }

identifier { VariableName }

// Allow both lowercase and uppercase names for const bindings (e.g., const Partial = ...)
// Also used for arrow params like (T) => T where T is a type variable
identifierOrTypeName { VariableName ~arrow | TypeName ~arrow }

// Property names can be either lowercase or uppercase identifiers
// This is a grammar rule, not a token, to avoid tokenizer ambiguity
// ~record marks GLR split point for { x } ambiguity (expression vs record field)
// Keywords are also allowed as property names (like JavaScript)
// Note: Literal keywords (true, false, null, undefined) are excluded to avoid
// conflicts with literal expressions in block/record ambiguity
PropertyName {
  VariableName ~record |
  TypeName ~record |
  kw<"type"> ~record |
  kw<"const"> ~record |
  kw<"async"> ~record |
  kw<"await"> ~record |
  kw<"match"> ~record |
  kw<"case"> ~record |
  kw<"when"> ~record |
  kw<"import"> ~record |
  kw<"export"> ~record |
  kw<"from"> ~record |
  kw<"as"> ~record |
  kw<"newtype"> ~record |
  kw<"comptime"> ~record |
  kw<"throw"> ~record |
  kw<"extends"> ~record
}

// ============================================
// Tokens
// ============================================

@tokens {
  whitespace { $[ \t\n\r]+ }

  LineComment { "//" ![\n]* }
  BlockComment { "/*" blockCommentContent* "*/" }
  blockCommentContent { ![*] | "*" ![/] }

  String {
    '"' (![\\\n"] | "\\" _)* '"' |
    "'" (![\\\n'] | "\\" _)* "'"
  }

  // Template literals
  // TemplatePlain: simple template with no interpolation `hello`
  // TemplateStart: beginning of interpolated template `hello ${
  // TemplateMiddle: middle part between interpolations } world ${
  // TemplateEnd: end of interpolated template } goodbye`
  templateContent { ![`$\\] | "\\" _ | "$" ![{] }
  TemplatePlain { "`" templateContent* "`" }
  TemplateStart { "`" templateContent* "${" }
  TemplateMiddle { "}" templateContent* "${" }
  TemplateEnd { "}" templateContent* "`" }

  Number {
    @digit+ ("." @digit+)? ($[eE] $[+\-]? @digit+)? |
    "0x" $[0-9a-fA-F]+ |
    "0b" $[01]+ |
    "0o" $[0-7]+
  }

  TypeName { $[A-Z] $[a-zA-Z0-9_]* }
  VariableName { $[a-z_] $[a-zA-Z0-9_]* }

  "="
  ";" "," "." ":" "?"[@name=Question] "@"
  "(" ")" "[" "]" "{" "}"
  "{|" "|}"
  "=>"
  "..."
  "_"

  "+"[@name=ArithOp] "-"[@name=ArithOp] "*"[@name=ArithOp] "/"[@name=ArithOp] "%"[@name=ArithOp]

  "=="[@name=CompareOp] "!="[@name=CompareOp]
  "<="[@name=CompareOp] ">="[@name=CompareOp] ">"[@name=CompareOp]

  "&&"[@name=LogicOp] "||"[@name=LogicOp]

  // Distinguish | and & in tokens to help with type syntax
  BitOr[@name="|"] { "|" }
  BitAnd[@name="&"] { "&" }

  "^"[@name=BitOp]
  "!" "~"

  @precedence { BlockComment, LineComment, "/" }
  @precedence { Number, "." }
  @precedence { "{|", "{" }
  @precedence { "|}", BitOr }
  @precedence { "...", "." }
  @precedence { "_", TypeName, VariableName }
  // Template tokens: prefer interpolated over plain, and template continuations over bare }
  @precedence { TemplateStart, TemplatePlain }
  @precedence { TemplateMiddle, TemplateEnd, "}" }
}

@skip { whitespace | LineComment | BlockComment }

// Operator precedence (low to high)
@precedence {
  ternary @right,
  or @left,
  and @left,
  bitor @left,
  bitxor @left,
  bitand @left,
  equality @left,
  compare @left,
  add @left,
  mult @left,
  unary @right,
  await @right,
  typeCall @left,
  call @left,
  member @left,
  union @left,
  intersection @left
}

@external propSource highlighting from "./highlight"

@detectDelim
